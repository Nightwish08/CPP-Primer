* 引用就是别名，只是一个已存在对象的另一个名字，**引用必须初始化**
```cpp
int& ref; // 错误，引用必须初始化

int* p = nullptr;
int& r = *p; // 错误，引用必须初始化
```
* 引用定义后，**程序把引用和初始值绑定在一起**，为引用赋值实际上是把值赋给了与引用绑定的对象，获取引用值实际上是获取引用绑定的对象的值
* **引用不是对象，不能定义引用的引用，也不能定义指向引用的指针**，可以定义指针的引用
```cpp
int i = 42;
int* p;
int* &r = p;
r = &i; // r就是p，等价于让p指向i
*r = 0;
```
* 引用只能绑定在对象上，而不能绑定在字面值或表达式的计算结果上，引用类型必须匹配（const引用例外）
```cpp
int &r = 10; // 错误，但const int &r = 10正确
double d = 3.14;
int &r2 = d; // 错误，引用类型的初始值必须是int型对象
```
* 普通引用不能绑定const对象，但普通对象可以被const引用绑定
```cpp
const int ci = 1024;
const int &r1 = ci; // 如果是int ci = 1024也可以绑，且改ci会改r1
r1 = 42; // 错误，r1是const引用，不能修改
int &r2 = ci; // 错误，普通引用不能绑定const对象
// int j = ci是可以的，常量可以赋值给非常量，和引用不同
```
* 引用符号后面接const没有意义
```cpp
int i = 10;
int& const r = i; // 即int& r = i;
```
* 初始化const引用允许用任意表达式作为初始值，可以类型不匹配，只要该表达式的结果能转换成引用的类型即可
```cpp
int i = 42;
const int &r1 = i; // 修改i会改变r1
cout << r1 << endl; // 42
i = 43;
cout << r1 << endl; // 43

const int &r2 = 42; // 直接绑定字面值是可以的

const int &r3 = r1 * 2; // 在绑定时确定值，此时r1为43，所以r3为86
// 之后修改i不会改变r3，r3是一个永远不变的const
cout << r3 << endl; // 86
i = 1; // 修改i会改变r1，不会改变r3
cout << r3 << endl; //86

int &r4 = r1 * 2; // 错误，r4是一个普通的非常量引用
```
* 普通引用不能绑定类型不匹配的对象的原因
```cpp
double d = 3.14;
const int &r = d;
// 编译器把上述代码变成了如下形式
const int temp = d;
const int &r = temp;
// 此时r绑定了一个临时对象，若r是普通引用，对其赋值会改变对象值
// 但改的其实是temp，d并没有变化，这样并没有达到预期目的
```
*  一条语句中可以定义多个引用，每个引用标识符都要以&开头
```cpp
int i = 1024,  i2 = 2048;
int& r = i, r2 = i2; // r是引用，r2是int
int i3 = 1024, &ri = i3; // i3是int，ri是引用
```
