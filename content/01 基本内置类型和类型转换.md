* 虽然字符型被分为char、signed char、unsigned char三种，但表现形式只有带符号和不带符号两种，所以char和signed char并不一样，char由编译器决定表现为另外两种形式中的哪种
* 算术表达式中不要用char或者bool，char在不同机器上有无符号均有可能，bool会把值转换成0或1，运算容易出问题。如果要用一个不大的整数，明确指出类型是signed char还是unsigned char
```cpp
bool b = true;
bool b2 = -b; // b2是true（-1不是0，所以是true）
```
* char能存储8位，即-128\~127或0\~255，所以如果出现上述问题难以发现
```cpp
int *p = new int[10];
*(p + 1) = 128; // p[1] = 128
char *q = reinterpret_cast<char*>p;
cout << static_cast<int>(*(q + 4)); // q指向的值128，char类型未知，结果可能是128，也可能是-128
```
* 已知数值不可能为负则选用无符号类型
* 实际中，short太小，long一般和int一样大，所以超过int范围时用long long（C++11）
* 浮点数运算用double，因为float通常精度不够，而且双精度和单精度浮点数的计算代价相差无几，对某些机器双精度运算甚至比单精度快。long double提供的精度一般没必要用，开销太大
* 类型转换
```cpp
bool b = 42; // b为true
int i = b; // i的值为1
i = 3.14; // i的值为3
double pi = i; // pi的值为3.0
unsigned char c = -1; // 假设char占8bit，char的值为255（-1%256）
signed char c2 = 256; // 假设char占8bit，c2的值未定义
// 未定义时程序可能工作或者崩溃或者产生垃圾数据
```
* 尽量避免依赖于实现环境的行为，把int大小当作固定值用的程序就是不可移植的
```cpp
__int16 i;
__int32 j;
__int64 k;
cout << sizeof(i) << sizeof(j) << sizeof(k); // 248
```
* 避免混用带符号类型和无符号类型
```cpp
unsigned u = 10;
int i = -42;
std::cout << i + i << std::endl; // -84
std::cout << u + i << std::endl; // 2^32-32 = 4294967264，先把i转成无符号数2^32-42再相加
```
* 避免用无符号数造成死循环
```cpp
for (unsigned u = 10; u >= 0; --u) // u永远不会小于0
```
* 无符号数死循环的问题通常出现于对容器的for循环遍历
```cpp
for (std::size_t sz = v.size(); sz >= 0; --v) // std::size_t也是无符号数
```
* 避免直接对double用==比较，因为精度丢失将出现预期之外的行为
```cpp
double d1 = 10;
double d2 = 20;
if(d1 == d1 * 2) cout << "a"; // 打印a

double d3 = 100;
double d4 = 110;
if(d4 == d3 * 1.1) cout << "b"; // 不打印
```
* 判断double相等的正确做法是将差值与一个极小数比较
```cpp
double d3 = 100;
double d4 = 110;
if(d4-d3*1.1 < 1e-6) cout << "b"; // 打印b
```
* 可以将整型字面值写作十进制、八进制或十六进制形式，0开头代表八进制，0x或0X开头代表十六进制
```cpp
int i = 012; // 10
i = 0xA2; // 162
i = 0xa3; // 163
i = 09; // ERROR
```
* 字符串字面值的类型实际上是const数组，编译器会在字符串末尾加一个空字符'\0'，因此字符串长度比内容多1。转义序列会被当成一个字符
```cpp
cout << sizeof("A") << sizeof("\n"); // 22
```
* 转义序列除了'\n'这类，还可以\x接1个或多个十六进制数字，或\接1-3个八进制数字，超过3个时只有前三个和\构成转义序列
```cpp
cout << sizeof("\xA2") << sizeof("\123") << sizeof("\1234"); \\ 2233
```
* 注意函数参数中存在的类型转换，比如isdigit判断一个参数是否为十进制数字字符（即0到9），参数类型会转换为char
```cpp
char c = '9';
if (isdigit(c)) ... // true
int i = 3;
if (isdigit(i)) ... // false
i = '3';
if (isdigit(c)) ... // true
i = 48;
if (isdigit(c)) ... // true：'0'到'9'对应的ASCII码值为48到57
i = 3;
if (isdigit(c+48)) ... // true：对应'3'的ASCII码值
```
